package fan.frozen.inventoryuimanager.inventory.constants;

import fan.frozen.inventoryuimanager.Utils.CommonUtil;
import fan.frozen.inventoryuimanager.api.Component;
import fan.frozen.inventoryuimanager.inventory.compnents.Border;
import fan.frozen.inventoryuimanager.inventory.constructor.AbstractInventory;
import org.bukkit.event.Event;
import org.bukkit.inventory.ItemStack;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;

/**
 * the preset of the border component<br>
 * we provided three kinds of different preset for you to choice
 */
public enum BorderPreset {
    /**
     * get border preset by {@link BorderPreset#getBorder(AbstractInventory, boolean, ItemStack, int)}
     */
    AROUND_BORDER(){
        @Override
        public Border getBorder(AbstractInventory abstractInventory,boolean ignoreComponents,ItemStack material,int parameter) {
            int[] deploySlots = CommonUtil.getIntArrayFromAToB(0,8);
            int lines = parameter /9;
            for (int i = 1; i < lines; i++) {
               if ((i-1)*9==0)continue;
               deploySlots = CommonUtil.addElements(deploySlots,(i-1)*9);
               deploySlots = CommonUtil.addElements(deploySlots,(i*9)-1);
            }
            deploySlots = CommonUtil.addElements(deploySlots,CommonUtil.getIntArrayFromAToB((lines-1)*9, parameter -1));
            deploySlots = checkComponentsLocations(abstractInventory, ignoreComponents, deploySlots);
            return new Border("autoGeneratedAroundBorder-"+hashCode(),material,0,true,deploySlots);
        }
    },
    /**
     * get border preset by {@link BorderPreset#getBorder(AbstractInventory, boolean, ItemStack, int)}
     */
    VERTICAL_BORDER(){
        @Override
        public Border getBorder(AbstractInventory abstractInventory, boolean ignoreComponents, ItemStack material, int parameter) {
            int size = abstractInventory.getInventory().getSize();
            int lines = size/9;
            int[] deploySlots = new int[0];
            if (parameter<1){
                parameter = 1;
            }else if (parameter>9){
                parameter = 9;
            }
            for (int i = 0; i < lines; i++) {
                deploySlots = CommonUtil.addElements(deploySlots,(parameter-1)+9);
            }
            BorderPreset.checkComponentsLocations(abstractInventory,ignoreComponents,deploySlots);
            return new Border("autoGeneratedVerticalBorder-"+hashCode(),material,0,true,deploySlots);
        }
    },
    /**
     * get border preset by {@link BorderPreset#getBorder(AbstractInventory, boolean, ItemStack, int)}
     */
    HORIZONTAL_BORDER(){
        @Override
        public Border getBorder(AbstractInventory abstractInventory, boolean ignoreComponents, ItemStack material, int parameter) {
            int size = abstractInventory.getInventory().getSize();
            parameter = parameter-1;
            if (parameter<=1){
                parameter=0;
            }else if (parameter>=size/9){
                parameter = (size/9)-1;
            }
            int[] deploySlots = CommonUtil.getIntArrayFromAToB(parameter*9,(parameter*9)+8);
            deploySlots = checkComponentsLocations(abstractInventory, ignoreComponents, deploySlots);
            return new Border("autoGeneratedHorizontalBorder-"+hashCode(),material,0,true,deploySlots);
        }
    };

    /**
     * check the border is conflicted with other components or borders
     * you can't define the priority of a component for now
     * so basically this is depended on which component is registered first it has higher priority
     * we will fix this in the later version
     * if they were conflicted, we just remove the location of the component from the border deploy location
     * @param abstractInventory the abstractInventory border need to be deployed
     * @param ignoreComponents should we check on the components locations conflicted with border, if false, border will cover the component
     * @param deploySlots locations of border will deploy
     * @return the locations border will be deployed at
     */
    private static int[] checkComponentsLocations(AbstractInventory abstractInventory, boolean ignoreComponents, int[] deploySlots) {
        if (!ignoreComponents){
            ArrayList<Integer> allRegisterComponentsLocations = new ArrayList<>();
            //first, we run through every registered component in the inventory where the border needs to be deployed
            for (Component<? extends Event> registeredComponent : abstractInventory.getRegisteredComponents()) {
                //then check if this component is a border already deployed in this inventory
                if (registeredComponent instanceof Border border){
                    //if it is, then add all the slots which have been taken by the previous border to the tobeRemoveSlots array
                    for (int deploySlot : border.getDeploySlots()) {
                        allRegisterComponentsLocations.add(deploySlot);
                    }
                }else {
                    //if it is not, then we get its location by getLocation() method
                    allRegisterComponentsLocations.add(registeredComponent.getLocation());
                }
            }
            ArrayList<Integer> currentBorderLocation = new ArrayList<>();
            Collections.addAll(currentBorderLocation, Arrays.stream(deploySlots).boxed().toArray(Integer[]::new));
            //at last, we remove these slots from the border's ready to deploy locations
            for (Integer allRegisterComponentsLocation : allRegisterComponentsLocations) {
                currentBorderLocation.remove(allRegisterComponentsLocation);
            }
            /*
            this step is because we are using the arrayList to store tobeRemovedSlots, which can only use Integer as
            field, so we have to remap it into int array, which is really necessary
             */
            deploySlots = currentBorderLocation.stream().mapToInt(Integer::valueOf).toArray();
        }
        return deploySlots;
    }

    public abstract Border getBorder(AbstractInventory abstractInventory, boolean ignoreComponents, ItemStack material,int parameter);
}
